<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="这是React的面试题汇总">
<title>React 面试题汇总2</title>

<link rel='canonical' href='https://trinyoung.github.io/interview/p/test-chinese2/'>

<link rel="stylesheet" href="/interview/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="React 面试题汇总2">
<meta property='og:description' content="这是React的面试题汇总">
<meta property='og:url' content='https://trinyoung.github.io/interview/p/test-chinese2/'>
<meta property='og:site_name' content='Trinyoung'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2020-10-09T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2020-10-09T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="React 面试题汇总2">
<meta name="twitter:description" content="这是React的面试题汇总">
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/interview/">
                
                    
                    
                    
                        
                        <img src="/interview/img/avatar_hu6696643109827554558.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/interview">Trinyoung</a></h1>
            <h2 class="site-description">欢迎来到我的博客</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/interview/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/interview/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/interview/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/interview/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/interview/%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#1-说一下react的生命周期以及对应的钩子函数">1. 说一下react的生命周期，以及对应的钩子函数？</a>
      <ol>
        <li><a href="#1-挂载阶段-mounting">1. <strong>挂载阶段 (Mounting)</strong></a></li>
        <li><a href="#2-更新阶段-updating">2. <strong>更新阶段 (Updating)</strong></a></li>
        <li><a href="#3-卸载阶段-unmounting">3. <strong>卸载阶段 (Unmounting)</strong></a></li>
        <li><a href="#4-错误处理-error-handling">4. <strong>错误处理 (Error Handling)</strong></a></li>
        <li><a href="#react-163-以后新生命周期方法与已废弃方法">React 16.3 以后新生命周期方法与已废弃方法</a></li>
        <li><a href="#图示帮助理解">图示帮助理解</a></li>
        <li><a href="#总结">总结</a></li>
      </ol>
    </li>
    <li><a href="#2-说一下什么是jsx">2. 说一下什么是jsx?</a>
      <ol>
        <li><a href="#特点与原理"><strong>特点与原理</strong></a></li>
        <li><a href="#优势"><strong>优势</strong></a></li>
        <li><a href="#注意事项"><strong>注意事项</strong></a></li>
      </ol>
    </li>
    <li><a href="#3-对比一下react-jsx-和-vue-中的-template-模板语法有何区别">3. 对比一下react jsx 和 vue 中的 template 模板语法有何区别？</a>
      <ol>
        <li><a href="#1-语法层面">1. <strong>语法层面</strong></a></li>
        <li><a href="#2-灵活性">2. <strong>灵活性</strong></a></li>
        <li><a href="#3-编译原理">3. <strong>编译原理</strong></a></li>
        <li><a href="#4-开发体验">4. <strong>开发体验</strong></a></li>
        <li><a href="#5-状态与数据绑定">5. <strong>状态与数据绑定</strong></a></li>
        <li><a href="#总结-1"><strong>总结</strong></a></li>
      </ol>
    </li>
    <li><a href="#3-说一下react-类组件和函数组件的区别">3. 说一下react 类组件和函数组件的区别？</a>
      <ol>
        <li><a href="#1-语法和定义">1. <strong>语法和定义</strong></a></li>
        <li><a href="#2-状态管理和生命周期">2. <strong>状态管理和生命周期</strong></a></li>
        <li><a href="#3-性能和效率">3. <strong>性能和效率</strong></a></li>
        <li><a href="#4-可读性和代码简洁性">4. <strong>可读性和代码简洁性</strong></a></li>
        <li><a href="#5-开发体验">5. <strong>开发体验</strong></a></li>
        <li><a href="#6-未来趋势">6. <strong>未来趋势</strong></a></li>
        <li><a href="#总结-2"><strong>总结</strong></a></li>
      </ol>
    </li>
    <li><a href="#4-为什么react-和-vue-都选择了hook">4. 为什么react 和 vue 都选择了hook？</a>
      <ol>
        <li><a href="#1-逻辑复用性增强">1. <strong>逻辑复用性增强</strong></a></li>
        <li><a href="#2-函数式编程的特性">2. <strong>函数式编程的特性</strong></a></li>
        <li><a href="#3-解决组件复杂度问题">3. <strong>解决组件复杂度问题</strong></a></li>
        <li><a href="#4-性能优化">4. <strong>性能优化</strong></a></li>
        <li><a href="#5-未来的趋势和生态">5. <strong>未来的趋势和生态</strong></a></li>
        <li><a href="#总结-3">总结</a></li>
      </ol>
    </li>
    <li><a href="#什么是hoc">什么是HOC?</a></li>
    <li><a href="#哪些方法会触发react重新渲染重新渲染render-会做些什么">哪些方法会触发React重新渲染？重新渲染render 会做些什么？</a></li>
    <li><a href="#react-的事件机制是如何实现的">react 的事件机制是如何实现的？</a>
      <ol>
        <li><a href="#1-合成事件synthetic-event">1. <strong>合成事件（Synthetic Event）</strong></a></li>
        <li><a href="#2-事件委托">2. <strong>事件委托</strong></a></li>
        <li><a href="#3-事件冒泡与捕获">3. <strong>事件冒泡与捕获</strong></a></li>
        <li><a href="#4-事件池化">4. <strong>事件池化</strong></a></li>
        <li><a href="#5-阻止默认行为与停止冒泡">5. <strong>阻止默认行为与停止冒泡</strong></a></li>
        <li><a href="#6-事件绑定方式">6. <strong>事件绑定方式</strong></a></li>
        <li><a href="#7-性能优化批量更新">7. <strong>性能优化：批量更新</strong></a></li>
        <li><a href="#总结-4">总结：</a></li>
      </ol>
    </li>
    <li><a href="#说一下什么是虚拟dom它如何工作">说一下什么是虚拟DOM？它如何工作？</a>
      <ol>
        <li><a href="#1-什么是虚拟-dom">1. <strong>什么是虚拟 DOM？</strong></a></li>
        <li><a href="#2-虚拟-dom-工作流程">2. <strong>虚拟 DOM 工作流程</strong></a>
          <ol>
            <li><a href="#step-1-构建虚拟-dom"><strong>Step 1: 构建虚拟 DOM</strong></a></li>
            <li><a href="#step-2-状态更新生成新的虚拟-dom"><strong>Step 2: 状态更新，生成新的虚拟 DOM</strong></a></li>
            <li><a href="#step-3-diff-算法比较新旧虚拟-dom"><strong>Step 3: Diff 算法比较新旧虚拟 DOM</strong></a></li>
            <li><a href="#step-4-计算差异reconciliation"><strong>Step 4: 计算差异（Reconciliation）</strong></a></li>
            <li><a href="#step-5-更新真实-dom"><strong>Step 5: 更新真实 DOM</strong></a></li>
          </ol>
        </li>
        <li><a href="#3-虚拟-dom-的优势">3. <strong>虚拟 DOM 的优势</strong></a></li>
        <li><a href="#4-diff-算法的工作原理">4. <strong>Diff 算法的工作原理</strong></a></li>
        <li><a href="#5-虚拟-dom-的局限性">5. <strong>虚拟 DOM 的局限性</strong></a></li>
        <li><a href="#总结-5"><strong>总结</strong></a></li>
      </ol>
    </li>
    <li><a href="#对react-fiber的理解它解决了什么问题">对react fiber的理解，它解决了什么问题？</a>
      <ol>
        <li><a href="#1-为什么需要-fiber">1. 为什么需要 Fiber</a></li>
        <li><a href="#2-react-fiber-的核心概念">2. React Fiber 的核心概念</a></li>
        <li><a href="#3-react-fiber-的工作阶段">3. React Fiber 的工作阶段</a></li>
        <li><a href="#4-fiber-和传统-stack-reconciler-的区别">4. Fiber 和传统 Stack Reconciler 的区别</a></li>
        <li><a href="#5-fiber-的应用场景">5. Fiber 的应用场景</a></li>
        <li><a href="#6-fiber-的限制">6. Fiber 的限制</a></li>
        <li><a href="#总结-6">总结</a></li>
      </ol>
    </li>
    <li><a href="#react-component-和-purecomponent-的区别">React Component 和 PureComponent 的区别？</a></li>
    <li><a href="#谈一谈对-react-context-的理解">谈一谈对 React Context 的理解</a>
      <ol>
        <li><a href="#1-主要用途">1. 主要用途</a></li>
        <li><a href="#2-创建-context">2. 创建 Context</a></li>
        <li><a href="#3-provider-和-consumer">3. Provider 和 Consumer</a></li>
        <li><a href="#4-使用-usecontext-hook">4. 使用 <code>useContext</code> Hook</a></li>
        <li><a href="#5-示例">5. 示例</a></li>
        <li><a href="#6-性能考虑">6. 性能考虑</a></li>
        <li><a href="#7-适用场景">7. 适用场景</a></li>
        <li><a href="#8-限制">8. 限制</a></li>
        <li><a href="#9-结合其他状态管理工具">9. 结合其他状态管理工具</a></li>
        <li><a href="#10-总结">10. 总结</a></li>
      </ol>
    </li>
    <li><a href="#react-中什么是受控组件什么是非受控组件">react 中什么是受控组件，什么是非受控组件？</a>
      <ol>
        <li><a href="#1-受控组件controlled-components">1. 受控组件（Controlled Components）</a></li>
        <li><a href="#2-非受控组件uncontrolled-components">2. 非受控组件（Uncontrolled Components）</a></li>
        <li><a href="#总结-7">总结</a></li>
      </ol>
    </li>
    <li><a href="#react-中refs-中有哪些应用场景">react 中refs 中有哪些应用场景</a>
      <ol>
        <li><a href="#1-访问-dom-元素">1. 访问 DOM 元素</a></li>
        <li><a href="#2-管理动画">2. 管理动画</a></li>
        <li><a href="#3-集成第三方库">3. 集成第三方库</a></li>
        <li><a href="#4-表单管理">4. 表单管理</a></li>
        <li><a href="#5-访问子组件实例">5. 访问子组件实例</a></li>
        <li><a href="#6-处理焦点管理">6. 处理焦点管理</a></li>
        <li><a href="#7-访问组件的-dom-节点">7. 访问组件的 DOM 节点</a></li>
        <li><a href="#8-处理滚动位置">8. 处理滚动位置</a></li>
        <li><a href="#总结-8">总结</a></li>
        <li><a href="#1-用途">1. 用途</a></li>
        <li><a href="#2-更新机制">2. 更新机制</a></li>
        <li><a href="#3-数据持久性">3. 数据持久性</a></li>
        <li><a href="#4-适用场景">4. 适用场景</a></li>
        <li><a href="#5-性能">5. 性能</a></li>
        <li><a href="#总结-9">总结</a></li>
      </ol>
    </li>
    <li><a href="#类组件和函数组件有何异同">类组件和函数组件有何异同？</a>
      <ol>
        <li><a href="#一类组件与函数组件的异同"><strong>一、类组件与函数组件的异同</strong></a>
          <ol>
            <li><a href="#1-定义方式">1. <strong>定义方式</strong></a></li>
            <li><a href="#2-状态管理">2. <strong>状态管理</strong></a></li>
            <li><a href="#3-生命周期">3. <strong>生命周期</strong></a></li>
            <li><a href="#4-this-关键字">4. <strong><code>this</code> 关键字</strong></a></li>
            <li><a href="#5-性能-1">5. <strong>性能</strong></a></li>
          </ol>
        </li>
        <li><a href="#二代表的思想"><strong>二、代表的思想</strong></a>
          <ol>
            <li><a href="#1-类组件面向对象编程-oop">1. <strong>类组件：面向对象编程 (OOP)</strong></a></li>
            <li><a href="#2-函数组件函数式编程-fp">2. <strong>函数组件：函数式编程 (FP)</strong></a></li>
          </ol>
        </li>
        <li><a href="#总结-10"><strong>总结</strong></a></li>
      </ol>
    </li>
    <li><a href="#react-setstate的调用原理">React setState的调用原理</a>
      <ol>
        <li><a href="#1-状态更新的异步性">1. 状态更新的异步性</a></li>
        <li><a href="#2-更新队列的合并">2. 更新队列的合并</a></li>
        <li><a href="#3-处理更新队列">3. 处理更新队列</a></li>
        <li><a href="#4-例子">4. 例子</a></li>
        <li><a href="#5-使用函数式更新">5. 使用函数式更新</a></li>
        <li><a href="#总结-11">总结</a></li>
      </ol>
    </li>
    <li><a href="#完整的说一下当路由进入到当前的react页面时整个流程是什么">完整的说一下当路由进入到当前的react页面时，整个流程是什么？</a></li>
    <li><a href="#heading"></a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/interview/categories/react/" >
                React
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/interview/p/test-chinese2/">React 面试题汇总2</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            这是React的面试题汇总
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Oct 09, 2020</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 29 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="1-说一下react的生命周期以及对应的钩子函数">1. 说一下react的生命周期，以及对应的钩子函数？
</h2><p>React 的生命周期方法主要分为<strong>三个阶段</strong>：<strong>挂载阶段 (Mounting)</strong>、<strong>更新阶段 (Updating)</strong> 和 <strong>卸载阶段 (Unmounting)</strong>。这些生命周期方法在类组件中尤为明显，下面详细介绍各个阶段的生命周期和对应的钩子函数：</p>
<h3 id="1-挂载阶段-mounting">1. <strong>挂载阶段 (Mounting)</strong>
</h3><p>当组件实例被创建并插入到 DOM 中时，触发以下钩子函数：</p>
<ul>
<li>
<p><code>constructor()</code></p>
<ul>
<li><strong>触发时机</strong>：组件被初始化时调用。</li>
<li><strong>作用</strong>：用于初始化状态 <code>state</code> 和绑定事件处理方法。</li>
</ul>
</li>
<li>
<p><code>static getDerivedStateFromProps(props, state)</code></p>
<ul>
<li><strong>触发时机</strong>：在组件实例化时以及每次更新前被调用。</li>
<li><strong>作用</strong>：返回新的状态对象，或返回 <code>null</code> 表示状态不需要更新。</li>
</ul>
</li>
<li>
<p><code>render()</code></p>
<ul>
<li><strong>触发时机</strong>：每次组件渲染时调用。</li>
<li><strong>作用</strong>：返回组件的 JSX。</li>
</ul>
</li>
<li>
<p><code>componentDidMount()</code></p>
<ul>
<li><strong>触发时机</strong>：组件第一次渲染完成后调用。</li>
<li><strong>作用</strong>：适合进行异步请求、数据获取或设置订阅等操作。</li>
</ul>
</li>
</ul>
<h3 id="2-更新阶段-updating">2. <strong>更新阶段 (Updating)</strong>
</h3><p>当组件的 props 或 state 发生变化时，会进入更新阶段，触发以下钩子函数：</p>
<ul>
<li>
<p><code>static getDerivedStateFromProps(props, state)</code></p>
<ul>
<li>与挂载阶段一致，每次更新前都会被调用。</li>
</ul>
</li>
<li>
<p><code>shouldComponentUpdate(nextProps, nextState)</code></p>
<ul>
<li><strong>触发时机</strong>：在组件更新之前调用。</li>
<li><strong>作用</strong>：返回 <code>true</code> 或 <code>false</code> 决定组件是否需要重新渲染，默认返回 <code>true</code>。</li>
</ul>
</li>
<li>
<p><code>render()</code></p>
<ul>
<li>在组件更新阶段会再次被调用，用于重新渲染组件。</li>
</ul>
</li>
<li>
<p><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></p>
<ul>
<li><strong>触发时机</strong>：更新发生在 DOM 更新之前调用。</li>
<li><strong>作用</strong>：捕获一些 DOM 信息，例如滚动位置，可以返回值作为 <code>componentDidUpdate</code> 的第三个参数。</li>
</ul>
</li>
<li>
<p><code>componentDidUpdate(prevProps, prevState, snapshot)</code></p>
<ul>
<li><strong>触发时机</strong>：组件更新后调用。</li>
<li><strong>作用</strong>：可以进行 DOM 操作或再次发起请求。</li>
</ul>
</li>
</ul>
<h3 id="3-卸载阶段-unmounting">3. <strong>卸载阶段 (Unmounting)</strong>
</h3><p>当组件从 DOM 中移除时，触发以下钩子函数：</p>
<ul>
<li><code>componentWillUnmount()</code>
<ul>
<li><strong>触发时机</strong>：组件即将卸载和销毁时调用。</li>
<li><strong>作用</strong>：可以用于清理定时器、取消订阅等。</li>
</ul>
</li>
</ul>
<h3 id="4-错误处理-error-handling">4. <strong>错误处理 (Error Handling)</strong>
</h3><p>当组件渲染或生命周期方法中抛出错误时，触发以下钩子函数：</p>
<ul>
<li>
<p><code>static getDerivedStateFromError(error)</code></p>
<ul>
<li><strong>触发时机</strong>：当子组件抛出错误时调用。</li>
<li><strong>作用</strong>：用于更新 state 以显示错误界面。</li>
</ul>
</li>
<li>
<p><code>componentDidCatch(error, info)</code></p>
<ul>
<li><strong>触发时机</strong>：当子组件抛出错误时调用。</li>
<li><strong>作用</strong>：用于记录错误信息或进行错误处理。</li>
</ul>
</li>
</ul>
<h3 id="react-163-以后新生命周期方法与已废弃方法">React 16.3 以后新生命周期方法与已废弃方法
</h3><ul>
<li>React 16.3 开始，推荐使用 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code>。</li>
<li>旧的生命周期方法如 <code>componentWillMount</code>、<code>componentWillReceiveProps</code> 和 <code>componentWillUpdate</code> 在严格模式下被标记为不安全，并计划在未来版本中删除。</li>
</ul>
<h3 id="图示帮助理解">图示帮助理解
</h3><p>一个图示可以更好地帮助你了解 React 生命周期的顺序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">Mounting</span><span class="p">:</span>        <span class="n">constructor</span> <span class="err">→</span> <span class="n">getDerivedStateFromProps</span> <span class="err">→</span> <span class="n">render</span> <span class="err">→</span> <span class="n">componentDidMount</span>
</span></span><span class="line"><span class="cl"><span class="n">Updating</span><span class="p">:</span>        <span class="n">getDerivedStateFromProps</span> <span class="err">→</span> <span class="n">shouldComponentUpdate</span> <span class="err">→</span> <span class="n">render</span> <span class="err">→</span> <span class="n">getSnapshotBeforeUpdate</span> <span class="err">→</span> <span class="n">componentDidUpdate</span>
</span></span><span class="line"><span class="cl"><span class="n">Unmounting</span><span class="p">:</span>      <span class="n">componentWillUnmount</span>
</span></span><span class="line"><span class="cl"><span class="n">Error</span> <span class="n">Handling</span><span class="p">:</span>  <span class="n">getDerivedStateFromError</span> <span class="err">→</span> <span class="n">componentDidCatch</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="总结">总结
</h3><p>React 生命周期方法让我们在不同阶段对组件进行控制，类组件中常用这些钩子函数来实现数据请求、资源管理和性能优化等操作。</p>
<h2 id="2-说一下什么是jsx">2. 说一下什么是jsx?
</h2><p><strong>JSX (JavaScript XML)</strong> 是一种 JavaScript 的语法扩展，通常用于在 React 中描述用户界面。它看起来非常像 HTML，但实际上在浏览器中运行之前会被编译成 JavaScript 函数调用。</p>
<h3 id="特点与原理"><strong>特点与原理</strong>
</h3><ol>
<li>
<p><strong>语法类似于 HTML</strong>:
JSX 允许你在 JavaScript 代码中编写类似 HTML 的标签语法，可以直接描述组件的结构，这让 UI 代码更具可读性和直观性。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">Hello</span><span class="p">,</span> <span class="nx">World</span><span class="o">!</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>需要编译</strong>:
浏览器无法直接理解 JSX，所以需要通过如 Babel 这样的编译器将其转换为标准的 JavaScript 代码。例如，上述 JSX 代码在编译后会变成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;h1&#39;</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="s1">&#39;Hello, World!&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>表达式与嵌套</strong>:
JSX 允许在 <code>{}</code> 中嵌入 JavaScript 表达式。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;John&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">Hello</span><span class="p">,</span> <span class="p">{</span><span class="nx">name</span><span class="p">}</span><span class="o">!</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>属性与子元素</strong>:
你可以向 JSX 元素传递属性和嵌套子元素，类似于 HTML。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="o">=</span><span class="s">&#34;container&#34;</span><span class="p">&gt;&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">Hello</span><span class="p">,</span> <span class="nx">JSX</span><span class="o">!</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h3 id="优势"><strong>优势</strong>
</h3><ul>
<li><strong>直观性</strong>: JSX 让 UI 组件的结构与逻辑紧密结合在一起，开发者可以直观地看到组件的渲染结构。</li>
<li><strong>更强的可维护性</strong>: 与分离的 HTML、CSS 和 JS 不同，JSX 通过组合组件的方式，提供了更好的模块化能力。</li>
</ul>
<h3 id="注意事项"><strong>注意事项</strong>
</h3><ul>
<li><strong>JSX 是表达式</strong>: JSX 可以赋值给变量、作为函数参数、从函数中返回，灵活性很高。</li>
<li><strong>属性规范</strong>: 在 JSX 中，<code>class</code> 应该写为 <code>className</code>，<code>for</code> 应该写为 <code>htmlFor</code>，以符合 JavaScript 的命名规则。</li>
</ul>
<p><strong>总结</strong>: JSX 是一种将 UI 与逻辑相结合的语法糖，它使得 React 组件的开发变得更高效、直观和可维护。在使用 React 开发应用时，JSX 是一种核心的工具。</p>
<h2 id="3-对比一下react-jsx-和-vue-中的-template-模板语法有何区别">3. 对比一下react jsx 和 vue 中的 template 模板语法有何区别？
</h2><p>React JSX 和 Vue 中的模板语法都是用来描述视图结构的，但两者在设计理念、灵活性、语法特性等方面有明显的区别。以下是它们的主要区别：</p>
<h3 id="1-语法层面">1. <strong>语法层面</strong>
</h3><ul>
<li>
<p><strong>React JSX</strong>:</p>
<ul>
<li>更接近 JavaScript，允许在 JSX 中直接编写 JavaScript 表达式，因此具有更强的灵活性和可编程性。</li>
<li>支持 JavaScript 原生控制语句（如 <code>if</code>、<code>for</code> 等），需要借助三元表达式或逻辑运算符来实现条件渲染和列表渲染。</li>
<li>JSX 使用 HTML 标签作为函数调用的语法糖，实际上会被编译成 <code>React.createElement</code> 方法。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">isLoggedIn</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span><span class="nx">isLoggedIn</span> <span class="o">?</span> <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">Welcome</span> <span class="nx">back</span><span class="o">!</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span> <span class="o">:</span> <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">Please</span> <span class="nx">sign</span> <span class="k">in</span><span class="p">.&lt;/</span><span class="nt">h1</span><span class="p">&gt;}</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>Vue Template</strong>:</p>
<ul>
<li>采用类似于 HTML 的模板语法，允许使用特殊的指令（如 <code>v-if</code>、<code>v-for</code> 等）来实现条件渲染和列表渲染，这些指令更贴近 HTML，简单易用。</li>
<li>Vue 的模板不直接包含复杂的 JavaScript 逻辑，而是通过指令和表达式来描述视图，更注重视图的声明式描述。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vue" data-lang="vue"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">h1</span> <span class="nt">v-if</span><span class="o">=</span><span class="s">&#34;isLoggedIn&#34;</span><span class="p">&gt;</span><span class="na">Welcome</span> <span class="na">back</span><span class="err">!</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">&lt;</span><span class="nt">h1</span> <span class="nt">v-else</span><span class="p">&gt;</span><span class="na">Please</span> <span class="na">sign</span> <span class="na">in.</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">&lt;/</span><span class="nt">template</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="2-灵活性">2. <strong>灵活性</strong>
</h3><ul>
<li>
<p><strong>React JSX</strong>:</p>
<ul>
<li>可以在 JSX 中编写复杂的逻辑，所有表达式都是 JavaScript 代码，具有更高的灵活性和可定制性。你可以将组件的渲染逻辑与 JavaScript 的条件判断、循环、函数等结合使用。</li>
</ul>
</li>
<li>
<p><strong>Vue Template</strong>:</p>
<ul>
<li>更强调视图与逻辑的分离，模板部分主要用于描述视图结构。虽然模板中也可以编写简单的表达式，但不支持复杂的控制逻辑，较为简洁和易读。</li>
</ul>
</li>
</ul>
<h3 id="3-编译原理">3. <strong>编译原理</strong>
</h3><ul>
<li>
<p><strong>React JSX</strong>:</p>
<ul>
<li>JSX 会被编译成 <code>React.createElement</code> 调用，在运行时生成虚拟 DOM，最终由 React 渲染成真实 DOM。</li>
</ul>
</li>
<li>
<p><strong>Vue Template</strong>:</p>
<ul>
<li>Vue 模板会被编译成渲染函数 (<code>render</code> 函数)，然后在运行时生成虚拟 DOM。这使得 Vue 在运行时与 React 类似，但模板语法的编译过程相对复杂。</li>
</ul>
</li>
</ul>
<h3 id="4-开发体验">4. <strong>开发体验</strong>
</h3><ul>
<li>
<p><strong>React JSX</strong>:</p>
<ul>
<li>更自由和灵活，适合复杂逻辑的表达，但代码可能显得较为繁琐，尤其对于没有 JavaScript 背景的开发者来说，理解成本较高。</li>
</ul>
</li>
<li>
<p><strong>Vue Template</strong>:</p>
<ul>
<li>更接近传统 HTML，学习成本低，对于初学者和前端开发者来说更加友好，模板语法简单直观。</li>
</ul>
</li>
</ul>
<h3 id="5-状态与数据绑定">5. <strong>状态与数据绑定</strong>
</h3><ul>
<li>
<p><strong>React JSX</strong>:</p>
<ul>
<li>数据绑定是单向的，需要通过 <code>setState</code> 或者 Hooks（如 <code>useState</code>）来更新组件状态。</li>
</ul>
</li>
<li>
<p><strong>Vue Template</strong>:</p>
<ul>
<li>支持双向数据绑定（使用 <code>v-model</code>），使得表单控件的处理更加方便。</li>
</ul>
</li>
</ul>
<h3 id="总结-1"><strong>总结</strong>
</h3><ul>
<li><strong>React JSX</strong> 更适合具有 JavaScript 编程能力的开发者，提供更大的灵活性和更强的逻辑处理能力。</li>
<li><strong>Vue Template</strong> 则更专注于视图的声明式描述，更加易读、易学，尤其对于初学者和专注于前端视图开发的工程师更友好。</li>
</ul>
<p>两者各有优势，选择取决于团队技术背景、项目复杂度以及开发者对视图逻辑的偏好。</p>
<h2 id="3-说一下react-类组件和函数组件的区别">3. 说一下react 类组件和函数组件的区别？
</h2><p>React 类组件和函数组件是 React 中用于定义组件的两种不同方式。它们在语法、性能、特性等方面存在一定的区别，以下是它们的详细对比：</p>
<h3 id="1-语法和定义">1. <strong>语法和定义</strong>
</h3><ul>
<li>
<p><strong>类组件 (Class Component)</strong>:</p>
<ul>
<li>通过 ES6 类语法定义，继承自 <code>React.Component</code>，并且必须包含一个 <code>render</code> 方法，该方法返回 JSX。</li>
<li>通常使用类的方法来处理生命周期和状态。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyComponent</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">count</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>函数组件 (Function Component)</strong>:</p>
<ul>
<li>使用 JavaScript 函数定义，直接接收 <code>props</code> 作为参数，并返回 JSX。</li>
<li>通过 React Hooks（如 <code>useState</code> 和 <code>useEffect</code>）来处理状态和生命周期。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="2-状态管理和生命周期">2. <strong>状态管理和生命周期</strong>
</h3><ul>
<li>
<p><strong>类组件</strong>:</p>
<ul>
<li>具有内置的状态管理能力，通过 <code>this.state</code> 和 <code>this.setState</code> 来管理状态。</li>
<li>提供了完整的生命周期方法，例如 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code> 等，可以更细粒度地控制组件的生命周期。</li>
</ul>
</li>
<li>
<p><strong>函数组件</strong>:</p>
<ul>
<li>没有原生的状态管理和生命周期方法，需要使用 React Hooks（如 <code>useState</code>、<code>useEffect</code> 等）来实现相同的功能。</li>
<li>Hooks 可以更方便地组织逻辑，并且可以在一个组件中组合多个 <code>useEffect</code> 实现逻辑的分离。</li>
</ul>
</li>
</ul>
<h3 id="3-性能和效率">3. <strong>性能和效率</strong>
</h3><ul>
<li>
<p><strong>类组件</strong>:</p>
<ul>
<li>在 React 16.8 以前，类组件是唯一可以管理状态的方式，但是由于类组件包含更多的逻辑和开销（如 <code>this</code> 绑定），相对来说性能不如函数组件高效。</li>
</ul>
</li>
<li>
<p><strong>函数组件</strong>:</p>
<ul>
<li>函数组件通常更轻量，不需要 <code>this</code> 绑定，性能上更加高效，尤其是搭配 React Hooks 的使用。</li>
<li>React 团队建议在新项目中优先使用函数组件，因为它们更简洁且性能更优。</li>
</ul>
</li>
</ul>
<h3 id="4-可读性和代码简洁性">4. <strong>可读性和代码简洁性</strong>
</h3><ul>
<li>
<p><strong>类组件</strong>:</p>
<ul>
<li>代码相对复杂，容易出现冗余，特别是在状态和事件处理时需要 <code>this</code> 绑定。</li>
<li>对于初学者来说，可能会因为 <code>this</code> 关键字的使用而增加理解难度。</li>
</ul>
</li>
<li>
<p><strong>函数组件</strong>:</p>
<ul>
<li>代码更加简洁，易读易维护，避免了 <code>this</code> 相关的困扰。</li>
<li>更符合函数式编程的风格，可以通过 Hooks 使逻辑更直观地组合和复用。</li>
</ul>
</li>
</ul>
<h3 id="5-开发体验">5. <strong>开发体验</strong>
</h3><ul>
<li>
<p><strong>类组件</strong>:</p>
<ul>
<li>由于类组件具有完整的生命周期方法，可以更明确地进行生命周期阶段的控制，适用于一些复杂的业务场景。</li>
</ul>
</li>
<li>
<p><strong>函数组件</strong>:</p>
<ul>
<li>Hooks 的引入使函数组件的功能更加丰富，并且可以实现与类组件相同的状态管理和副作用处理，开发体验上更加现代化。</li>
</ul>
</li>
</ul>
<h3 id="6-未来趋势">6. <strong>未来趋势</strong>
</h3><ul>
<li>React 从 16.8 版本开始引入了 Hooks，Hooks 已经成为官方推荐的管理状态和副作用的方式。React 官方表示，未来的新功能和特性会更加侧重于函数组件，因此函数组件被认为是 React 未来的发展方向。</li>
</ul>
<h3 id="总结-2"><strong>总结</strong>
</h3><ul>
<li><strong>类组件</strong> 更适合传统 React 开发方式，适用于需要完整生命周期管理或对老项目进行维护的场景。</li>
<li><strong>函数组件</strong> 更简洁、性能更高，结合 Hooks 提供了更强的灵活性和开发体验，是现代 React 开发的首选。</li>
</ul>
<p>在实际开发中，建议优先使用函数组件，只有在需要兼容老项目或特定场景时才使用类组件。</p>
<h2 id="4-为什么react-和-vue-都选择了hook">4. 为什么react 和 vue 都选择了hook？
</h2><p>Vue 和 React 都选择引入 Hooks 的原因主要有以下几个方面：</p>
<h3 id="1-逻辑复用性增强">1. <strong>逻辑复用性增强</strong>
</h3><ul>
<li><strong>问题</strong>：在 Vue 和 React 的传统组件开发方式中，逻辑复用通常需要通过高阶组件 (HOC) 或混入 (Mixins) 来实现，这种方式会导致代码结构变得复杂，逻辑难以追踪，增加了维护成本。</li>
<li><strong>Hooks 的优势</strong>：Hooks 提供了一种更加直观和轻量的方式来实现逻辑复用。开发者可以将组件中的逻辑提取到独立的 Hook 函数中，并在不同组件中直接调用，实现逻辑的共享和复用。例如，React 中的 <code>useState</code>、<code>useEffect</code>，Vue 中的 <code>ref</code>、<code>watchEffect</code> 等都使逻辑分离更加容易。</li>
</ul>
<h3 id="2-函数式编程的特性">2. <strong>函数式编程的特性</strong>
</h3><ul>
<li><strong>函数组件和组合式 API</strong>：Hooks 引入了函数式编程的特性，使得组件逻辑更加清晰和简洁。React 和 Vue 都在函数组件或组合式 API 中使用 Hooks，将状态和生命周期管理函数化，使代码更易读、易维护。</li>
<li><strong>函数更易组合</strong>：通过 Hooks，可以更方便地将逻辑模块化，从而实现代码的组合和复用。例如，在 Vue 3 中使用 <code>setup</code> 函数可以将相关的逻辑组织在一起，使组件内部的代码结构更加清晰。</li>
</ul>
<h3 id="3-解决组件复杂度问题">3. <strong>解决组件复杂度问题</strong>
</h3><ul>
<li><strong>类组件的问题</strong>：React 类组件和 Vue 2.x 的选项式 API 在处理复杂状态逻辑时，会导致代码变得难以管理，特别是生命周期方法分散在各个部分，导致逻辑的割裂。而 Hooks 通过函数形式，将相关的逻辑组合到一起，解决了类组件的复杂性问题。</li>
<li><strong>Hooks 带来的优势</strong>：通过 React Hooks 和 Vue 3 的组合式 API，状态、生命周期、事件等逻辑可以在一个函数作用域内处理，代码变得更加易读和维护。</li>
</ul>
<h3 id="4-性能优化">4. <strong>性能优化</strong>
</h3><ul>
<li><strong>更轻量的组件</strong>：函数组件加上 Hooks 在性能上往往更轻量，因为函数组件不需要实例化类，减少了内存和性能开销。</li>
<li><strong>对渲染的控制</strong>：React 中的 Hooks 允许开发者通过 <code>useMemo</code>、<code>useCallback</code> 等手段来优化渲染性能。同样地，Vue 3 也引入了 <code>computed</code> 和 <code>watch</code> 来实现对性能的优化。</li>
</ul>
<h3 id="5-未来的趋势和生态">5. <strong>未来的趋势和生态</strong>
</h3><ul>
<li><strong>统一 API 和开发体验</strong>：通过 Hooks，React 和 Vue 都实现了状态管理、生命周期管理、逻辑复用等功能的一致化，使开发体验更统一和一致，也更容易将项目从类组件过渡到函数组件或组合式 API。</li>
<li><strong>社区和生态的推动</strong>：React Hooks 和 Vue 3 的组合式 API 已经得到了社区的广泛支持，越来越多的第三方库也开始兼容和支持 Hooks，推动了它们的普及。</li>
</ul>
<h3 id="总结-3">总结
</h3><p>Vue 和 React 都选择 Hooks 是为了：</p>
<ul>
<li>提高逻辑复用性，解决原本组件开发中逻辑难以复用的问题。</li>
<li>提供更简洁、清晰、函数式的开发方式，改善代码组织和可维护性。</li>
<li>提供更强大的性能优化手段，适应现代前端开发的需求。</li>
<li>顺应未来的开发趋势，统一 API，推动生态发展。</li>
</ul>
<p>两者虽然有不同的设计理念，但在 Hooks 这一点上，目标是一致的：<strong>通过函数式的方式让开发更高效、灵活、易维护</strong>。</p>
<h2 id="什么是hoc">什么是HOC?
</h2><p>HOC（Higher-Order Component）是 React 中的一个概念，它指的是一个函数，该函数接受一个组件作为参数，返回一个新的组件。HOC 的主要作用是<strong>将一些通用的逻辑提取出来，并将其封装成一个函数，然后通过 HOC 的方式来复用这些逻辑</strong>。
高阶组件（HOC）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由react自身的组合性质必然产生的。我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。
1）HOC的优缺点
● 优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。
● 缺点∶hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖</p>
<p>2）适用场景
● 代码复用，逻辑抽象
● 渲染劫持
● State 抽象和更改
● Props 更改</p>
<h2 id="哪些方法会触发react重新渲染重新渲染render-会做些什么">哪些方法会触发React重新渲染？重新渲染render 会做些什么？
</h2><h2 id="react-的事件机制是如何实现的">react 的事件机制是如何实现的？
</h2><p>React 的事件机制与传统的 DOM 事件机制有所不同，它实现了一套基于合成事件（Synthetic Event）的系统。合成事件是一种跨浏览器的事件封装，用来统一不同浏览器的事件行为，同时提高性能。下面是 React 事件机制的详细实现过程：</p>
<h3 id="1-合成事件synthetic-event">1. <strong>合成事件（Synthetic Event）</strong>
</h3><p>React 为了解决浏览器的兼容性问题，创建了一套自己的事件系统，称为“合成事件”。合成事件是对原生事件的封装，确保在不同浏览器下事件行为一致。</p>
<p>合成事件具有以下特点：</p>
<ul>
<li>React 会拦截所有原生事件，并将它们转换为合成事件。</li>
<li>合成事件对象模仿了原生事件对象，但不直接来自浏览器的事件对象。</li>
<li>合成事件会被自动回收并重用，提升性能。</li>
</ul>
<h3 id="2-事件委托">2. <strong>事件委托</strong>
</h3><p>React 的事件处理基于事件委托机制。它并不会为每个 DOM 元素绑定事件处理器，而是在组件的根节点（通常是 <code>document</code> 或 <code>#root</code>）上统一绑定所有事件。</p>
<p>事件委托的工作原理：</p>
<ul>
<li>当用户触发事件时，事件冒泡到根节点，在根节点上统一处理事件。</li>
<li>React 会根据触发事件的目标元素和事件类型，在内部进行事件调度和分发，找到对应的组件和事件处理函数。</li>
</ul>
<p>这样做的好处：</p>
<ul>
<li>减少内存消耗：不需要为每个元素都绑定独立的事件处理器。</li>
<li>简化事件管理：所有事件都集中处理，统一调度。</li>
</ul>
<h3 id="3-事件冒泡与捕获">3. <strong>事件冒泡与捕获</strong>
</h3><p>React 的事件系统支持事件冒泡和事件捕获。你可以通过 <code>capture</code> 属性指定是否使用捕获阶段来处理事件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClick</span><span class="p">}</span> <span class="na">onClickCapture</span><span class="o">=</span><span class="p">{</span><span class="nx">handleCapture</span><span class="p">}&gt;</span><span class="nx">Click</span> <span class="nx">me</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>onClick</code> 默认会在冒泡阶段触发。</li>
<li><code>onClickCapture</code> 则会在捕获阶段触发。</li>
</ul>
<h3 id="4-事件池化">4. <strong>事件池化</strong>
</h3><p>React 使用事件池（event pooling）来优化性能。每次触发事件时，React 并不会为每个事件分配一个新的对象，而是复用旧的事件对象。</p>
<p>合成事件对象在事件处理函数执行完成后会被重置和回收，因此在事件回调函数中异步使用事件对象时，必须先调用 <code>event.persist()</code>，以避免事件对象被重用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">handleClick</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">event</span><span class="p">.</span><span class="nx">persist</span><span class="p">();</span>  <span class="c1">// 保留事件对象，防止其被复用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">type</span><span class="p">);</span> <span class="c1">// 可以安全使用事件对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="5-阻止默认行为与停止冒泡">5. <strong>阻止默认行为与停止冒泡</strong>
</h3><p>与原生 DOM 事件类似，React 的合成事件也提供了 <code>preventDefault()</code> 和 <code>stopPropagation()</code> 方法来阻止默认行为和事件冒泡。</p>
<ul>
<li><code>event.preventDefault()</code>：阻止浏览器执行事件的默认行为。</li>
<li><code>event.stopPropagation()</code>：阻止事件冒泡到父级元素。</li>
</ul>
<h3 id="6-事件绑定方式">6. <strong>事件绑定方式</strong>
</h3><p>在 React 中，事件处理函数通常通过 JSX 的形式绑定，语法上与原生 HTML 事件不同，React 使用小驼峰命名的事件属性，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClick</span><span class="p">}&gt;</span><span class="nx">Click</span> <span class="nx">me</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而不是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl"><span class="p">&lt;</span><span class="nt">button</span> <span class="na">onclick</span><span class="o">=</span><span class="s">&#34;handleClick()&#34;</span><span class="p">&gt;</span>Click me<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外，React 中事件处理函数的 <code>this</code> 指向默认情况下不会自动绑定到组件实例，必须手动绑定或使用箭头函数处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="c1">// 方法1：手动绑定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">MyComponent</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">handleClick</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>  <span class="c1">// 正确绑定到组件实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">}&gt;</span><span class="nx">Click</span> <span class="nx">me</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 方法2：使用箭头函数自动绑定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">class</span> <span class="nx">MyComponent</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>  <span class="c1">// 自动绑定到组件实例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">}&gt;</span><span class="nx">Click</span> <span class="nx">me</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="7-性能优化批量更新">7. <strong>性能优化：批量更新</strong>
</h3><p>React 的事件处理机制与其状态更新机制结合得非常紧密。React 在事件处理函数中触发状态更新时，通常会进行批量更新，而不是每次调用 <code>setState</code> 都立即触发重新渲染。批量更新减少了不必要的重新渲染，提高了性能。</p>
<h3 id="总结-4">总结：
</h3><p>React 的事件机制通过合成事件、事件委托和事件池化等技术实现了高效、跨浏览器一致的事件处理系统。开发者只需使用 React 提供的事件接口，专注于业务逻辑，而不必关心底层的事件绑定和优化问题。</p>
<h2 id="说一下什么是虚拟dom它如何工作">说一下什么是虚拟DOM？它如何工作？
</h2><p>虚拟 DOM（Virtual DOM）是 React 用于优化 UI 渲染性能的一种技术，它是对真实 DOM 的一种抽象表示，可以理解为在内存中以 JavaScript 对象形式存在的 DOM 树的副本。通过虚拟 DOM，React 可以高效地管理 UI 的更新，减少真实 DOM 操作的次数，从而提升性能。</p>
<h3 id="1-什么是虚拟-dom">1. <strong>什么是虚拟 DOM？</strong>
</h3><p>虚拟 DOM 是一个轻量级的 JavaScript 对象，它表示了 DOM 树的结构，包含了真实 DOM 元素的属性、节点关系以及内容等信息。虚拟 DOM 并不直接映射到浏览器，而是存在于内存中，当状态或数据发生变化时，React 首先在虚拟 DOM 上进行计算，然后将差异更新到真实 DOM 中。</p>
<h3 id="2-虚拟-dom-工作流程">2. <strong>虚拟 DOM 工作流程</strong>
</h3><p>当组件的状态或属性发生变化时，虚拟 DOM 的更新和渲染过程一般分为以下几个步骤：</p>
<h4 id="step-1-构建虚拟-dom"><strong>Step 1: 构建虚拟 DOM</strong>
</h4><ul>
<li>当应用初次渲染时，React 会根据组件的 <code>render()</code> 方法生成一棵虚拟 DOM 树。</li>
<li>这个虚拟 DOM 是由纯 JavaScript 对象组成的，描述了页面的初始状态。</li>
</ul>
<h4 id="step-2-状态更新生成新的虚拟-dom"><strong>Step 2: 状态更新，生成新的虚拟 DOM</strong>
</h4><ul>
<li>当组件的 <code>state</code> 或 <code>props</code> 发生变化时，React 会重新调用 <code>render()</code> 方法，生成一棵新的虚拟 DOM 树。</li>
</ul>
<h4 id="step-3-diff-算法比较新旧虚拟-dom"><strong>Step 3: Diff 算法比较新旧虚拟 DOM</strong>
</h4><ul>
<li>React 会使用 “Diff 算法” 比较新的虚拟 DOM 与旧的虚拟 DOM，找出两者之间的差异（即需要更新的部分）。</li>
<li>Diff 算法的复杂度被优化到 O(n)，意味着它只会检查有变化的节点，忽略没有变化的部分。</li>
</ul>
<h4 id="step-4-计算差异reconciliation"><strong>Step 4: 计算差异（Reconciliation）</strong>
</h4><ul>
<li>React 将新旧虚拟 DOM 的差异（称为“补丁”或“patch”）记录下来，这些差异包含了应该如何更新真实 DOM。</li>
</ul>
<h4 id="step-5-更新真实-dom"><strong>Step 5: 更新真实 DOM</strong>
</h4><ul>
<li>最后，React 会将这些差异应用到真实 DOM 中，进行必要的更新操作。由于 React 只会更新发生变化的部分，这极大地提高了渲染效率。</li>
</ul>
<h3 id="3-虚拟-dom-的优势">3. <strong>虚拟 DOM 的优势</strong>
</h3><ul>
<li><strong>性能优化</strong>：与直接操作真实 DOM 相比，虚拟 DOM 通过在内存中进行计算，大幅减少了对真实 DOM 的操作次数，从而提高了性能。</li>
<li><strong>跨平台能力</strong>：虚拟 DOM 是与平台无关的 JavaScript 对象，可以被用来生成多种目标输出，不仅限于浏览器的 DOM 操作。这使得 React 可以用于构建移动应用（如 React Native）。</li>
<li><strong>简化开发</strong>：开发者只需关注组件的状态变化，而无需手动操作 DOM，React 会自动进行更新和渲染，提供更简洁的开发体验。</li>
</ul>
<h3 id="4-diff-算法的工作原理">4. <strong>Diff 算法的工作原理</strong>
</h3><p>React 在更新虚拟 DOM 时，使用了一种高效的 Diff 算法来比较新旧虚拟 DOM 树，主要基于以下三条策略：</p>
<ol>
<li><strong>同级比较</strong>：只会对同一级别的节点进行比较，不会跨级比较，这样大大降低了计算复杂度。</li>
<li><strong>节点类型不同，直接替换</strong>：如果两个节点的类型不同（例如从 <code>&lt;div&gt;</code> 变为 <code>&lt;span&gt;</code>），则会直接移除旧节点及其子节点，并创建新的节点。</li>
<li><strong>通过 <code>key</code> 进行列表比较</strong>：当渲染列表时，React 通过每个节点的 <code>key</code> 值来识别节点的身份，从而准确、高效地处理节点的增删改操作。</li>
</ol>
<h3 id="5-虚拟-dom-的局限性">5. <strong>虚拟 DOM 的局限性</strong>
</h3><ul>
<li><strong>初次渲染性能</strong>：虚拟 DOM 在初次渲染时会生成整个虚拟 DOM 树，对于大型应用来说，初次渲染的性能可能会受到影响。</li>
<li><strong>不适用于所有场景</strong>：在高性能要求的场景（如 WebGL、游戏开发）中，手动优化可能比虚拟 DOM 更有效。</li>
</ul>
<h3 id="总结-5"><strong>总结</strong>
</h3><p>虚拟 DOM 是 React 提高渲染性能的核心技术，通过在内存中维护一个虚拟的 DOM 树，将每次状态变化引起的 DOM 更新变得更高效。它通过 Diff 算法计算新旧虚拟 DOM 之间的差异，并将最小的更新应用到真实 DOM，从而实现性能的优化和快速的界面更新。</p>
<h2 id="对react-fiber的理解它解决了什么问题">对react fiber的理解，它解决了什么问题？
</h2><p>React Fiber 是 React 16 版本引入的新架构，它是一种用于协调和渲染 React 应用的<strong>渐进式调度算法</strong>，旨在提高 React 应用的性能，特别是对于大型应用和复杂的动画效果。</p>
<h3 id="1-为什么需要-fiber">1. 为什么需要 Fiber
</h3><p>React 在早期的版本中，使用的是同步递归渲染机制，这意味着在一次更新中，React 会从根节点开始递归地进行渲染工作，直到整个组件树渲染完成。在大型组件树或复杂的渲染过程中，这可能会导致浏览器阻塞，导致页面卡顿或无法响应用户的交互。</p>
<p>为了提升性能和提高渲染的流畅度，React Fiber 引入了一种新的架构，能够将渲染工作拆分成<strong>更小的任务单元</strong>，并允许在任务之间进行调度，从而更好地控制渲染的优先级，避免阻塞主线程。</p>
<h3 id="2-react-fiber-的核心概念">2. React Fiber 的核心概念
</h3><ul>
<li><strong>Fiber 是一种数据结构</strong>：它将每个组件的更新任务以链表的形式存储，形成一个<strong>Fiber 树</strong>，使得 React 可以逐步地、增量地更新视图。</li>
<li><strong>可中断的渲染</strong>：Fiber 的最大优势是能够将渲染过程切分成小块，并且在必要的时候暂停、恢复或终止渲染任务，以确保高优先级的任务（如用户交互）能及时响应。</li>
<li><strong>优先级调度</strong>：Fiber 会根据不同任务的优先级分配时间片（time slices）。这样高优先级的任务（如动画、输入事件）会比低优先级的任务（如数据加载）更早地得到处理。</li>
</ul>
<h3 id="3-react-fiber-的工作阶段">3. React Fiber 的工作阶段
</h3><p>React Fiber 分为两个主要的阶段：</p>
<ol>
<li>
<p><strong>调度阶段（Reconciliation Phase）</strong>：这一阶段是计算哪些组件需要更新的过程。Fiber 会遍历整个 Fiber 树，构建一个新版本的 Fiber 树，并确定要进行的更改。在这一步中，Fiber 可以暂停或中断，等待空闲时间继续执行。</p>
</li>
<li>
<p><strong>提交阶段（Commit Phase）</strong>：这一阶段是将更新应用到实际的 DOM 中。在这个阶段，操作是真正同步执行的，并且无法被打断。</p>
</li>
</ol>
<h3 id="4-fiber-和传统-stack-reconciler-的区别">4. Fiber 和传统 Stack Reconciler 的区别
</h3><ul>
<li><strong>可中断性</strong>：传统的 Stack Reconciler 是同步的、递归的，不能中断，而 Fiber 是异步的、可中断的。</li>
<li><strong>优先级控制</strong>：Fiber 能根据任务的重要性对任务进行调度，而传统架构无法做到这一点。</li>
</ul>
<h3 id="5-fiber-的应用场景">5. Fiber 的应用场景
</h3><ul>
<li><strong>动画和流畅的用户交互</strong>：Fiber 能够让 React 应用在复杂的动画、过渡效果下保持流畅。</li>
<li><strong>大型组件树</strong>：对于渲染庞大组件树的应用，Fiber 能有效减少卡顿，确保高优先级的任务可以及时得到响应。</li>
</ul>
<h3 id="6-fiber-的限制">6. Fiber 的限制
</h3><p>虽然 React Fiber 引入了很多优点，但它也有一定的复杂性，例如调度算法的复杂性更高，同时它也会引入一定的性能开销，因此它并不是万能的优化工具，而是解决特定场景下性能问题的一种方案。</p>
<h3 id="总结-6">总结
</h3><p>React Fiber 提供了一种更灵活、更高效的渲染方式，通过引入渐进式的调度机制，实现了对渲染任务的可中断和优先级调度，从而在提高性能和流畅度方面提供了巨大优势。</p>
<h2 id="react-component-和-purecomponent-的区别">React Component 和 PureComponent 的区别？
</h2><p>默认行为：</p>
<p>Component 是 React 中的基本组件类，它不保证任何性能优化措施。
PureComponent 是对 Component 的一个优化版本，它实现了 shouldComponentUpdate 生命周期方法，提供了浅比较（shallow comparison）的优化。
性能优化：</p>
<p>使用 Component 时，开发者需要手动实现 shouldComponentUpdate 方法来控制组件是否需要更新。
PureComponent 自动实现了一个简单的 shouldComponentUpdate 实现，它会比较新旧 props 和 state，如果它们的引用不同或者值不同，则认为需要更新组件。这种浅比较可以避免不必要的渲染，提高性能。
适用场景：</p>
<p>如果组件的 props 或 state 变化频繁且复杂，不适合使用 PureComponent，因为它的浅比较机制可能无法准确判断是否需要更新。
对于简单且输入输出关系明确的组件，使用 PureComponent 可以减少开发者的负担，并且提升应用性能。
自定义比较逻辑：</p>
<p>在 Component 中可以通过自定义 shouldComponentUpdate 来实现更复杂的比较逻辑或条件判断。
PureComponent 不支持自定义 shouldComponentUpdate 的逻辑，如果需要更复杂的逻辑，仍然需要使用普通的 Component 并手动实现该方法。
总结来说，PureComponent 是一种轻量级的性能优化手段，适用于大多数情况下不需要复杂比较逻辑的组件。而 Component 提供了更大的灵活性，可以根据具体需求进行更细致的性能调优</p>
<h2 id="谈一谈对-react-context-的理解">谈一谈对 React Context 的理解
</h2><p>React Context 是 React 提供的一种用于在组件树中共享数据的机制，允许我们在不通过 props 逐层传递的情况下，轻松地在组件之间共享状态。以下是对 React Context 的详细理解：</p>
<h3 id="1-主要用途">1. 主要用途
</h3><ul>
<li><strong>全局状态管理</strong>：Context 适合用于共享全局状态，如用户认证信息、主题设置、语言选择等。</li>
<li><strong>避免 props drilling</strong>：在深层嵌套的组件中，使用 Context 可以避免通过每一层组件传递 props。</li>
</ul>
<h3 id="2-创建-context">2. 创建 Context
</h3><p>使用 <code>React.createContext()</code> 创建一个 Context 对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">MyContext</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createContext</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="3-provider-和-consumer">3. Provider 和 Consumer
</h3><ul>
<li><strong>Provider</strong>：用于提供 Context 的值，包裹需要访问该值的组件。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nx">MyContext</span><span class="p">.</span><span class="nx">Provider</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="cm">/* 共享的值 */</span><span class="p">}</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span><span class="cm">/* 子组件 */</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="err">/MyContext.Provider&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>Consumer</strong>：用于访问 Context 的值，通常在子组件中使用。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="o">&lt;</span><span class="nx">MyContext</span><span class="p">.</span><span class="nx">Consumer</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span><span class="nx">value</span> <span class="p">=&gt;</span> <span class="cm">/* 使用 Context 的值 */</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;</span><span class="err">/MyContext.Consumer&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="4-使用-usecontext-hook">4. 使用 <code>useContext</code> Hook
</h3><p>在函数组件中，可以使用 <code>useContext</code> Hook 更简洁地访问 Context 的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">useContext</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">useContext</span><span class="p">(</span><span class="nx">MyContext</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="5-示例">5. 示例
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">ThemeContext</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createContext</span><span class="p">(</span><span class="s1">&#39;light&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">App</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="nx">ThemeContext</span><span class="p">.</span><span class="nx">Provider</span> <span class="nx">value</span><span class="o">=</span><span class="s2">&#34;dark&#34;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="nx">Toolbar</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="err">/ThemeContext.Provider&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Toolbar</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="nx">ThemedButton</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">ThemedButton</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">theme</span> <span class="o">=</span> <span class="nx">useContext</span><span class="p">(</span><span class="nx">ThemeContext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">theme</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">I</span> <span class="nx">am</span> <span class="nx">styled</span> <span class="nx">by</span> <span class="nx">theme</span> <span class="nx">context</span><span class="o">!&lt;</span><span class="err">/button&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="6-性能考虑">6. 性能考虑
</h3><ul>
<li><strong>重渲染</strong>：当 Provider 的值发生变化时，所有使用该 Context 的组件都会重新渲染。因此，应该谨慎选择 Context 的值，避免不必要的重渲染。</li>
<li><strong>分割 Context</strong>：如果有多个状态需要共享，可以考虑将它们分割成多个 Context，以减少重渲染的范围。</li>
</ul>
<h3 id="7-适用场景">7. 适用场景
</h3><ul>
<li><strong>主题切换</strong>：在应用中实现主题切换功能。</li>
<li><strong>用户认证</strong>：在应用中共享用户的登录状态和信息。</li>
<li><strong>多语言支持</strong>：在应用中实现国际化，动态切换语言。</li>
</ul>
<h3 id="8-限制">8. 限制
</h3><ul>
<li><strong>不适合频繁变化的状态</strong>：对于频繁变化的状态（如表单输入），使用 Context 可能导致性能问题，建议使用局部状态管理。</li>
<li><strong>复杂性</strong>：在大型应用中，过度使用 Context 可能导致代码复杂性增加，难以维护。</li>
</ul>
<h3 id="9-结合其他状态管理工具">9. 结合其他状态管理工具
</h3><ul>
<li>Context 可以与其他状态管理工具（如 Redux、MobX）结合使用，作为全局状态的补充。</li>
<li>在小型应用中，Context 可以替代 Redux 等复杂的状态管理库。</li>
</ul>
<h3 id="10-总结">10. 总结
</h3><p>React Context 是一个强大的工具，适合用于在组件树中共享状态，避免 props drilling。它提供了一种简单的方式来管理全局状态，但在使用时需要注意性能和复杂性。合理地使用 Context 可以提高代码的可读性和可维护性。</p>
<h2 id="react-中什么是受控组件什么是非受控组件">react 中什么是受控组件，什么是非受控组件？
</h2><p>在 React 中，受控组件和非受控组件是两种处理表单输入的方式。它们的主要区别在于如何管理组件的状态。</p>
<h3 id="1-受控组件controlled-components">1. 受控组件（Controlled Components）
</h3><p><strong>定义</strong>：
受控组件是指其值由 React 组件的状态（state）控制的组件。所有的输入值都通过 React 的状态管理来处理。</p>
<p><strong>示例</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">ControlledComponent</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="p">[</span><span class="nx">value</span><span class="p">,</span> <span class="nx">setValue</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">handleChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">setValue</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text&#34;</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">value</span><span class="p">}</span> <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">handleChange</span><span class="p">}</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>优点</strong>：</p>
<ul>
<li><strong>单一数据源</strong>：所有的输入值都存储在组件的状态中，便于管理和调试。</li>
<li><strong>实时验证</strong>：可以在输入时进行验证和格式化。</li>
<li><strong>更好的控制</strong>：可以轻松地实现复杂的交互逻辑，如动态禁用按钮、条件渲染等。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>性能开销</strong>：每次输入都会触发状态更新，可能导致性能问题，尤其是在大型表单中。</li>
<li><strong>代码复杂性</strong>：需要编写额外的代码来管理状态和处理输入。</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>需要实时验证和格式化输入的场景。</li>
<li>需要根据输入动态更新其他组件或状态的场景。</li>
<li>需要在表单提交时获取所有输入值的场景。</li>
</ul>
<h3 id="2-非受控组件uncontrolled-components">2. 非受控组件（Uncontrolled Components）
</h3><p><strong>定义</strong>：
非受控组件是指其值不由 React 组件的状态控制，而是直接通过 DOM 元素的引用（ref）来访问。</p>
<p><strong>示例</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useRef</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">UncontrolledComponent</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">inputRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;A name was submitted: &#39;</span> <span class="o">+</span> <span class="nx">inputRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="nx">form</span> <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="nx">handleSubmit</span><span class="p">}</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text&#34;</span> <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">inputRef</span><span class="p">}</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;submit&#34;</span><span class="o">&gt;</span><span class="nx">Submit</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="err">/form&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>优点</strong>：</p>
<ul>
<li><strong>简单性</strong>：不需要管理状态，代码更简洁。</li>
<li><strong>性能</strong>：在某些情况下，性能更好，因为不需要频繁更新状态。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>难以控制</strong>：不容易实现实时验证和格式化。</li>
<li><strong>数据获取</strong>：在提交表单时需要通过 ref 获取数据，可能不够直观。</li>
<li><strong>不易调试</strong>：由于数据不在 React 的状态中，调试和跟踪数据变化可能更困难。</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>简单的表单，且不需要实时验证的场景。</li>
<li>需要快速实现的原型或小型应用。</li>
<li>处理第三方库或非 React 组件的场景。</li>
</ul>
<h3 id="总结-7">总结
</h3><ul>
<li><strong>受控组件</strong>：适合需要精确控制和实时反馈的场景，提供更好的可维护性和可调试性。</li>
<li><strong>非受控组件</strong>：适合简单场景，减少了状态管理的复杂性，但在复杂交互中可能不够灵活。</li>
</ul>
<p>选择使用受控组件还是非受控组件，取决于具体的应用需求和复杂性。在大多数情况下，受控组件是推荐的做法，因为它们提供了更好的控制和可维护性。</p>
<h2 id="react-中refs-中有哪些应用场景">react 中refs 中有哪些应用场景
</h2><p>在 React 中，<code>refs</code>（引用）是一个用于访问和操作 DOM 元素或 React 组件实例的工具。以下是一些常见的 <code>refs</code> 应用场景：</p>
<h3 id="1-访问-dom-元素">1. 访问 DOM 元素
</h3><ul>
<li><strong>直接操作 DOM</strong>：当需要直接访问和操作 DOM 元素时，可以使用 <code>refs</code>。例如，聚焦输入框、滚动到特定位置等。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useRef</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">FocusInput</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">inputRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">handleFocus</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">inputRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">focus</span><span class="p">();</span> <span class="c1">// 聚焦输入框
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">inputRef</span><span class="p">}</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text&#34;</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleFocus</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Focus</span> <span class="nx">Input</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="2-管理动画">2. 管理动画
</h3><ul>
<li><strong>控制动画</strong>：在需要控制动画的场景中，可以使用 <code>refs</code> 来访问 DOM 元素并应用动画效果。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useRef</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">AnimatedBox</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">boxRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">handleAnimate</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">boxRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">transform</span> <span class="o">=</span> <span class="s1">&#39;translateX(100px)&#39;</span><span class="p">;</span> <span class="c1">// 移动盒子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">boxRef</span><span class="p">}</span> <span class="nx">style</span><span class="o">=</span><span class="p">{{</span> <span class="nx">width</span><span class="o">:</span> <span class="s1">&#39;100px&#39;</span><span class="p">,</span> <span class="nx">height</span><span class="o">:</span> <span class="s1">&#39;100px&#39;</span><span class="p">,</span> <span class="nx">background</span><span class="o">:</span> <span class="s1">&#39;blue&#39;</span> <span class="p">}}</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleAnimate</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Animate</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="3-集成第三方库">3. 集成第三方库
</h3><ul>
<li><strong>与非 React 组件集成</strong>：在使用第三方库（如 jQuery、D3.js 等）时，可能需要直接访问 DOM 元素。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useRef</span><span class="p">,</span> <span class="nx">useEffect</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">$</span> <span class="nx">from</span> <span class="s1">&#39;jquery&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">JqueryComponent</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">divRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">useEffect</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">$</span><span class="p">(</span><span class="nx">divRef</span><span class="p">.</span><span class="nx">current</span><span class="p">).</span><span class="nx">fadeIn</span><span class="p">();</span> <span class="c1">// 使用 jQuery 操作 DOM
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">},</span> <span class="p">[]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">divRef</span><span class="p">}</span> <span class="nx">style</span><span class="o">=</span><span class="p">{{</span> <span class="nx">display</span><span class="o">:</span> <span class="s1">&#39;none&#39;</span> <span class="p">}}</span><span class="o">&gt;</span><span class="nx">Hello</span><span class="p">,</span> <span class="nx">jQuery</span><span class="o">!&lt;</span><span class="err">/div&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="4-表单管理">4. 表单管理
</h3><ul>
<li><strong>非受控组件</strong>：在某些情况下，使用 <code>refs</code> 可以简化表单管理，尤其是在处理第三方库或需要快速实现的场景。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useRef</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">UncontrolledForm</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">inputRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">handleSubmit</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;Input value: &#39;</span> <span class="o">+</span> <span class="nx">inputRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// 直接访问输入值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="nx">form</span> <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="nx">handleSubmit</span><span class="p">}</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">inputRef</span><span class="p">}</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;text&#34;</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&#34;submit&#34;</span><span class="o">&gt;</span><span class="nx">Submit</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;</span><span class="err">/form&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="5-访问子组件实例">5. 访问子组件实例
</h3><ul>
<li><strong>获取子组件方法</strong>：在类组件中，可以使用 <code>refs</code> 访问子组件实例，从而调用其方法。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Child</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;Hello from Child!&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="nx">Child</span> <span class="nx">Component</span><span class="o">&lt;</span><span class="err">/div&gt;;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Parent</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">childRef</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createRef</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">childRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span> <span class="c1">// 调用子组件方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="o">&lt;</span><span class="nx">Child</span> <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">childRef</span><span class="p">}</span> <span class="o">/&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Call</span> <span class="nx">Child</span> <span class="nx">Method</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="6-处理焦点管理">6. 处理焦点管理
</h3><ul>
<li><strong>焦点控制</strong>：在复杂的表单中，可以使用 <code>refs</code> 来管理焦点，确保用户体验流畅。</li>
</ul>
<h3 id="7-访问组件的-dom-节点">7. 访问组件的 DOM 节点
</h3><ul>
<li><strong>获取组件的 DOM 节点</strong>：在需要直接操作组件的 DOM 节点时，可以使用 <code>refs</code>。</li>
</ul>
<h3 id="8-处理滚动位置">8. 处理滚动位置
</h3><ul>
<li><strong>滚动管理</strong>：在需要控制滚动位置的场景中，可以使用 <code>refs</code> 来访问和操作滚动条。</li>
</ul>
<h3 id="总结-8">总结
</h3><p><code>refs</code> 在 React 中是一个强大的工具，适用于需要直接访问和操作 DOM 元素或组件实例的场景。尽管 <code>refs</code> 提供了灵活性，但应谨慎使用，避免过度依赖。通常情况下，推荐使用 React 的状态管理和生命周期方法来处理大多数场景，<code>refs</code> 应该用于特定的需求。</p>
<p><code>refs</code> 和 <code>useState</code> 是 React 中用于管理状态和引用的两种不同机制。它们各自有不同的用途和特性。以下是它们之间的主要区别：</p>
<h3 id="1-用途">1. 用途
</h3><ul>
<li>
<p><strong><code>useState</code></strong>：</p>
<ul>
<li>用于在函数组件中管理状态。</li>
<li>当状态更新时，组件会重新渲染。</li>
<li>适用于需要响应用户输入、异步请求或其他事件的场景。</li>
</ul>
</li>
<li>
<p><strong><code>refs</code></strong>：</p>
<ul>
<li>用于访问和操作 DOM 元素或 React 组件实例。</li>
<li>不会引起组件重新渲染。</li>
<li>适用于需要直接操作 DOM、集成第三方库或管理焦点等场景。</li>
</ul>
</li>
</ul>
<h3 id="2-更新机制">2. 更新机制
</h3><ul>
<li><strong><code>useState</code></strong>：
<ul>
<li>使用 <code>setState</code> 函数更新状态。</li>
<li>更新状态后，React 会重新渲染组件，反映最新的状态。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 触发重新渲染
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong><code>refs</code></strong>：
<ul>
<li>直接通过 <code>ref</code> 对象访问 DOM 元素或组件实例。</li>
<li>更新 <code>refs</code> 的值不会触发组件重新渲染。</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">inputRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">inputRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="s1">&#39;New Value&#39;</span><span class="p">;</span> <span class="c1">// 不会触发重新渲染
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="3-数据持久性">3. 数据持久性
</h3><ul>
<li>
<p><strong><code>useState</code></strong>：</p>
<ul>
<li>状态在组件的生命周期内持久化，组件重新渲染时状态保持不变。</li>
<li>状态可以是基本类型、对象或数组。</li>
</ul>
</li>
<li>
<p><strong><code>refs</code></strong>：</p>
<ul>
<li><code>refs</code> 的值在组件的生命周期内持久化，但不参与 React 的渲染过程。</li>
<li>适合存储不需要引起渲染的值，如 DOM 引用或计时器 ID。</li>
</ul>
</li>
</ul>
<h3 id="4-适用场景">4. 适用场景
</h3><ul>
<li>
<p><strong><code>useState</code></strong>：</p>
<ul>
<li>适用于需要响应用户交互、表单输入、异步数据请求等场景。</li>
<li>适合管理需要在 UI 中反映的状态。</li>
</ul>
</li>
<li>
<p><strong><code>refs</code></strong>：</p>
<ul>
<li>适用于需要直接操作 DOM 元素、集成第三方库、管理焦点等场景。</li>
<li>适合存储不需要在 UI 中反映的值。</li>
</ul>
</li>
</ul>
<h3 id="5-性能">5. 性能
</h3><ul>
<li>
<p><strong><code>useState</code></strong>：</p>
<ul>
<li>由于会引起重新渲染，频繁更新状态可能会影响性能。</li>
</ul>
</li>
<li>
<p><strong><code>refs</code></strong>：</p>
<ul>
<li>由于不引起重新渲染，使用 <code>refs</code> 可以避免不必要的性能开销。</li>
</ul>
</li>
</ul>
<h3 id="总结-9">总结
</h3><ul>
<li><strong><code>useState</code></strong> 是用于管理组件状态的钩子，适合需要响应用户交互的场景。</li>
<li><strong><code>refs</code></strong> 是用于访问和操作 DOM 元素或组件实例的工具，适合需要直接操作 DOM 的场景。</li>
</ul>
<p>在实际开发中，选择使用 <code>useState</code> 还是 <code>refs</code> 取决于具体的需求和场景。通常情况下，优先使用 <code>useState</code> 来管理需要在 UI 中反映的状态，而在需要直接操作 DOM 或不需要引起渲染的情况下使用 <code>refs</code>。</p>
<h2 id="类组件和函数组件有何异同">类组件和函数组件有何异同？
</h2><p>React 类组件和函数组件有以下异同，且代表了不同的思想：</p>
<h3 id="一类组件与函数组件的异同"><strong>一、类组件与函数组件的异同</strong>
</h3><h4 id="1-定义方式">1. <strong>定义方式</strong>
</h4><ul>
<li><strong>类组件</strong>：使用 ES6 的 <code>class</code> 关键字定义，继承自 <code>React.Component</code>，需要实现 <code>render()</code> 方法来返回 JSX。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyComponent</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="nx">Hello</span><span class="p">,</span> <span class="nx">Class</span> <span class="nx">Component</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><strong>函数组件</strong>：使用 JavaScript 函数定义，直接返回 JSX。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="nx">Hello</span><span class="p">,</span> <span class="nb">Function</span> <span class="nx">Component</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="2-状态管理">2. <strong>状态管理</strong>
</h4><ul>
<li><strong>类组件</strong>：通过 <code>this.state</code> 管理组件状态，使用 <code>this.setState()</code> 更新状态。</li>
<li><strong>函数组件</strong>：原先函数组件是无状态的，但自从 React 16.8 引入 Hooks 后，可以使用 <code>useState</code> 等 Hook 来管理状态。</li>
</ul>
<h4 id="3-生命周期">3. <strong>生命周期</strong>
</h4><ul>
<li><strong>类组件</strong>：提供了丰富的生命周期方法（如 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code> 等）来处理组件的不同阶段。</li>
<li><strong>函数组件</strong>：没有直接的生命周期方法，但可以使用 <code>useEffect</code> Hook 模拟生命周期行为。</li>
</ul>
<h4 id="4-this-关键字">4. <strong><code>this</code> 关键字</strong>
</h4><ul>
<li><strong>类组件</strong>：需要注意 <code>this</code> 的绑定问题，必须在构造函数中手动绑定，或者使用箭头函数解决。</li>
<li><strong>函数组件</strong>：不存在 <code>this</code> 问题，代码更加简洁。</li>
</ul>
<h4 id="5-性能-1">5. <strong>性能</strong>
</h4><ul>
<li><strong>类组件</strong>：由于需要实例化，性能上会略低于函数组件。</li>
<li><strong>函数组件</strong>：因为没有实例化过程，性能更优，尤其在引入 Hooks 后，可以满足大部分需求。</li>
</ul>
<h3 id="二代表的思想"><strong>二、代表的思想</strong>
</h3><h4 id="1-类组件面向对象编程-oop">1. <strong>类组件：面向对象编程 (OOP)</strong>
</h4><ul>
<li>类组件符合面向对象编程的思想，通过 <code>class</code> 定义组件，可以封装状态、方法和生命周期，并支持继承。</li>
<li>组件状态和行为都被封装在对象实例中，组件自身具有更强的独立性。</li>
</ul>
<h4 id="2-函数组件函数式编程-fp">2. <strong>函数组件：函数式编程 (FP)</strong>
</h4><ul>
<li>函数组件代表了函数式编程的思想，将组件视为纯函数，接收 <code>props</code> 作为输入，返回 UI 作为输出。</li>
<li>Hooks 的引入加强了函数式编程风格，使得状态和副作用也可以通过 Hook 函数实现。</li>
<li>函数组件更加简洁、直观，代码结构更清晰，避免了 <code>this</code> 的困扰，符合 React “UI 即函数”的理念。</li>
</ul>
<h3 id="总结-10"><strong>总结</strong>
</h3><ul>
<li>类组件和函数组件在实现方式、状态管理、生命周期和性能等方面有明显区别。</li>
<li>类组件代表面向对象编程思想，强调封装和继承；而函数组件代表函数式编程思想，提倡函数的纯粹性和数据不可变性。</li>
<li>在 Hooks 引入后，函数组件变得更加强大和灵活，React 官方也推荐优先使用函数组件进行开发。</li>
</ul>
<h2 id="react-setstate的调用原理">React setState的调用原理
</h2><p>是的，您描述的场景基本上是正确的。在 React 中，<code>setState</code> 的调用是异步的，多个状态更新会被合并到一个更新队列中，直到 React 处理这些更新并进行重新渲染。以下是这个过程的详细说明：</p>
<h3 id="1-状态更新的异步性">1. 状态更新的异步性
</h3><p>当您调用 <code>setState</code> 方法时，React 不会立即更新组件的状态和重新渲染组件。相反，它会将状态更新请求放入一个更新队列中。这种设计的目的是为了提高性能，避免不必要的渲染。</p>
<h3 id="2-更新队列的合并">2. 更新队列的合并
</h3><p>如果在同一个事件处理函数中多次调用 <code>setState</code>，React 会将这些状态更新合并为一个更新。这意味着，如果您在一个方法中调用了多次 <code>setState</code>，React 会将这些更新合并为一个状态更新操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">increment</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">count</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">});</span> <span class="c1">// 第一次更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">count</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">});</span> <span class="c1">// 第二次更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">count</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">});</span> <span class="c1">// 第三次更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的例子中，虽然调用了三次 <code>setState</code>，但 React 会将这些更新合并为一次更新，最终只会触发一次重新渲染。</p>
<h3 id="3-处理更新队列">3. 处理更新队列
</h3><p>React 会在合适的时机（例如事件处理完成后、定时器触发后等）处理更新队列。处理更新队列的过程如下：</p>
<ul>
<li><strong>合并状态更新</strong>：React 会合并所有在同一事件循环中的 <code>setState</code> 调用。</li>
<li><strong>计算新的状态</strong>：React 会根据合并后的状态计算出新的状态。</li>
<li><strong>触发重新渲染</strong>：一旦更新队列处理完成，React 会重新渲染组件，更新虚拟 DOM，并最终更新真实 DOM。</li>
</ul>
<h3 id="4-例子">4. 例子
</h3><p>以下是一个完整的例子，展示了如何在一个事件处理函数中合并多个状态更新：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Counter</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">count</span><span class="o">:</span> <span class="mi">0</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">increment</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">count</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">});</span> <span class="c1">// 更新 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">count</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">});</span> <span class="c1">// 更新 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">count</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">});</span> <span class="c1">// 更新 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里的 count 最终会是 3，而不是 6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Count</span><span class="o">:</span> <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">increment</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Increment</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="o">&lt;</span><span class="err">/div&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="5-使用函数式更新">5. 使用函数式更新
</h3><p>为了确保每次更新都基于最新的状态，您可以使用函数式更新：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="nx">increment</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">((</span><span class="nx">prevState</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">({</span> <span class="nx">count</span><span class="o">:</span> <span class="nx">prevState</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}));</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">((</span><span class="nx">prevState</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">({</span> <span class="nx">count</span><span class="o">:</span> <span class="nx">prevState</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">}));</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">((</span><span class="nx">prevState</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">({</span> <span class="nx">count</span><span class="o">:</span> <span class="nx">prevState</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">}));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 这里的 count 最终会是 6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="总结-11">总结
</h3><ul>
<li>React 的 <code>setState</code> 是异步的，多个状态更新会被合并到一个更新队列中。</li>
<li>处理更新队列时，React 会合并状态更新并触发一次重新渲染。</li>
<li>使用函数式更新可以确保每次更新都基于最新的状态。</li>
</ul>
<p>这种机制使得 React 在处理状态更新时更加高效，避免了不必要的渲染和性能开销。</p>
<h2 id="完整的说一下当路由进入到当前的react页面时整个流程是什么">完整的说一下当路由进入到当前的react页面时，整个流程是什么？
</h2><h2 id="heading">
</h2>
</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2024 Trinyoung
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.27.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/interview/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
